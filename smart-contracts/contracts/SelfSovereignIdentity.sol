// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19 <0.9.0;

struct Parent {
    bool valid;
    string parentId;
    string signature;
}

struct VerificationMethod {
    uint index;
    string id;
    string methodType;
    string controller;
    uint chainId;
    address blockchainAccountId;
}

struct Service {
    string id;
    string serviceType;
    string endpoint;
}

struct DidDocumentData {
    string id;
    bool deactivated;
    mapping(string => VerificationMethod) authentications;
    string[] authenticationIds;
    uint nextAuthenticationIndex;
    mapping(string => VerificationMethod) capabilityDelegations;
    string[] capabilityDelegationIds;
    uint nextCapabilityDelegationIndex;
    mapping(string => Service) services;
    string[] serviceIds;
    uint nextServiceIndex;
    Parent parent;
}

struct DidDocument {
    string id;
    bool deactivated;
    VerificationMethod[] authentication;
    VerificationMethod[] capabilityDelegation;
    Service[] service;
    Parent parent;
}

struct ResolutionResult {
    //didResolutionMetadata
    DidDocument didDocument;
    // didDocumentMetadata
}

struct ChainResolutionResult {
    string[] userDids;
}

contract SelfSovereignIdentity {
    mapping(string => DidDocumentData) private documents;
    // Development-only
    string[] private keys;

    //
    // Creates a new DID Document related to the user that has issued the transaction.
    //
    // @return The DID of the newly added user.
    //
    function createDid() public returns (string memory) {
        string memory userDid = addressToDid(msg.sender);

        initializeDidDocument(userDid, msg.sender);

        return userDid;
    }

    //
    // Creates a new DID Document stating the "delegation" of trust from the user that issued the
    // transaction (which acts as "certification authority") to the user with the specified DID.
    // Therefore, this method adds the specified DID as the last node of the chain of trust.
    //
    // @param childAddress The address that will be used to compute the DID of the user to which the
    //                     "certification authority" delegates the trust.
    // @param signature Signature generated by the "certification authority"
    // @return The DID of the newly added user.
    //
    function createChildTrustedDid(
        address childAddress,
        string memory signature
    ) public returns (string memory) {
        string memory childDid = addressToDid(childAddress);

        initializeDidDocument(childDid, childAddress);
        // TODO: the sender can use different DID -> verify identity via authentication
        documents[childDid].parent = Parent(true, addressToDid(msg.sender), signature);

        return childDid;
    }

    function initializeDidDocument(string memory userDid, address userAddress) private {
        string memory authenticationId = string.concat(userDid, "#key-1");
        VerificationMethod memory authentication = VerificationMethod(
            1,
            authenticationId,
            "EcdsaSecp256k1RecoveryMethod2020", // TODO:
            userDid,
            block.chainid,
            userAddress
        );

        DidDocumentData storage document = documents[userDid];

        document.id = userDid;
        document.deactivated = false;
        document.authentications[authenticationId] = authentication;
        document.authenticationIds.push(authenticationId);
        document.nextAuthenticationIndex = 2;
        document.nextCapabilityDelegationIndex = 1;
        document.nextServiceIndex = 1;

        // Development-only
        keys.push(userDid);
    }

    //
    // Adds a capability delegation from the user that issued the transaction to the user whose DID
    // will be computed from the specified address.
    // Therefore, the user that issued the transaction delegates to the specified user the
    // possibility to authenticate as the user that issued the transaction.
    //
    // @param controllerAddress The address of the user that will have the possibility to
    //                          authenticate as the user that issued the transaction.
    //
    function addCapabilityDelegation(address controllerAddress) public {
        string memory userDid = addressToDid(msg.sender);
        string memory controllerDid = addressToDid(controllerAddress);

        DidDocumentData storage userDidDocument = documents[userDid];
        string memory capabilityId = string.concat(
            userDid,
            "#capability-",
            uintToString(userDidDocument.nextCapabilityDelegationIndex)
        );

        VerificationMethod memory delegation = VerificationMethod(
            userDidDocument.nextCapabilityDelegationIndex,
            capabilityId,
            "EcdsaSecp256k1RecoveryMethod2020", // TODO,
            controllerDid,
            block.chainid,
            controllerAddress
        );

        userDidDocument.capabilityDelegations[capabilityId] = delegation;
        userDidDocument.capabilityDelegationIds.push(capabilityId);
        userDidDocument.nextCapabilityDelegationIndex++;
    }

    // TODO: function removeCapabilityDelegation() public {}
    //TODO: addKey
    //TODO: removeKey

    function addService(
        string memory serviceId,
        string memory serviceType,
        string memory endpoint
    ) public {
        DidDocumentData storage document = documents[addressToDid(msg.sender)];

        document.services[serviceId] = Service(serviceId, serviceType, endpoint);
        document.serviceIds.push(serviceId);
        document.nextServiceIndex++;
    }

    //TODO: function removeService(string memory serviceId) public {}

    //
    // Deactivates the DID document related to the user that issued the transaction.
    //
    function deactivate() public {
        documents[addressToDid(msg.sender)].deactivated = true;
    }

    //
    // Returns the DID document associated to the user with the specified DID.
    //
    // @param did DID of the user whose DID document will be returned.
    // @return The DID document associated to the user with the specified DID.
    //
    function resolve(string memory did) public view returns (ResolutionResult memory) {
        DidDocumentData storage document = documents[did];
        VerificationMethod[] memory authentications = new VerificationMethod[](
            document.authenticationIds.length
        );
        VerificationMethod[] memory capabilityDelegations = new VerificationMethod[](
            document.capabilityDelegationIds.length
        );
        Service[] memory services = new Service[](document.serviceIds.length);

        for (uint i = 0; i < authentications.length; i++) {
            authentications[i] = document.authentications[document.authenticationIds[i]];
        }

        for (uint i = 0; i < capabilityDelegations.length; i++) {
            capabilityDelegations[i] = document.capabilityDelegations[
                document.capabilityDelegationIds[i]
            ];
        }

        for (uint i = 0; i < services.length; i++) {
            services[i] = document.services[document.serviceIds[i]];
        }

        DidDocument memory documentToReturn = DidDocument(
            document.id,
            document.deactivated,
            authentications,
            capabilityDelegations,
            services,
            document.parent
        );

        return ResolutionResult(documentToReturn);
        // TODO. resolve(did, resolutionOptions) -> (didResolutionMetadata, didDocument, didDocumentMetadata)
    }

    //
    // Returns the chain of trust having as last node the user with the specified DID.
    //
    // @param The DID of the user to compute the chain of trust of.
    // @return The list of DIDs of the users in the chain of trust having the specified DID as the
    //          last node.
    //
    function resolveChain(string memory did) public view returns (ChainResolutionResult memory) {
        string[] memory userDids = new string[](10);
        DidDocumentData storage currentDocument = documents[did];
        uint8 index = 0;
        bool valid = true;

        do {
            userDids[index] = currentDocument.id;
            valid = currentDocument.parent.valid;
            if (valid) {
                currentDocument = documents[currentDocument.parent.parentId];
            }
            index++;
        } while (valid);

        return ChainResolutionResult(userDids);
    }

    // TODO: getCapabilityDelegations OR resolve().capabilityDelegations

    function getAuthentication(
        string calldata didUrl
    ) public view returns (VerificationMethod memory) {
        // did:ssi-toc-eth:1234:40

        string memory did = didUrl[0:61];
        DidDocumentData storage document = documents[did];

        return document.authentications[didUrl];
    }

    //
    // Deletes all the DID documents. This method is used for development purposes only.
    //
    function clear() public {
        uint size = keys.length;

        while (size > 0) {
            DidDocumentData storage document = documents[keys[size - 1]];

            // Delete authentications
            uint authenticationsCount = document.authenticationIds.length;
            while (authenticationsCount > 0) {
                delete document.authentications[
                    document.authenticationIds[authenticationsCount - 1]
                ];
                document.authenticationIds.pop();
                authenticationsCount--;
            }

            // Delete capabilities
            uint capabilitiesCount = document.capabilityDelegationIds.length;
            while (capabilitiesCount > 0) {
                delete document.capabilityDelegations[
                    document.capabilityDelegationIds[capabilitiesCount - 1]
                ];
                document.capabilityDelegationIds.pop();
                capabilitiesCount--;
            }

            // Delete services
            uint servicesCount = document.serviceIds.length;
            while (capabilitiesCount > 0) {
                delete document.capabilityDelegations[document.serviceIds[servicesCount - 1]];
                document.serviceIds.pop();
                servicesCount--;
            }

            delete documents[keys[size - 1]];
            keys.pop();
            size--;
        }
    }

    //
    // Converts the specified address to the corresponding DID.
    //
    // @param addressToConvert Address to convert to DID.
    // @return The computed DID.
    //
    function addressToDid(address addressToConvert) public view returns (string memory) {
        return
            string.concat(
                "did:ssi-cot-eth:",
                uintToString(block.chainid),
                ":",
                addressToString(addressToConvert)
            );
    }

    function uintToString(uint number) private pure returns (string memory) {
        if (number == 0) {
            return "0";
        }

        // Compute the length
        uint length = 0;
        uint numberCopy = number;
        while (numberCopy > 0) {
            length++;
            numberCopy /= 10;
        }

        bytes memory result = new bytes(length);
        uint index = length - 1;

        while (number > 0) {
            uint8 value = uint8(number % 10);
            result[index] = bytes1(48 + value);
            if (index != 0) {
                index--;
            }
            number /= 10;
        }

        return string(result);
    }

    function addressToString(address addr) private pure returns (string memory) {
        bytes20 addressBytes = bytes20(addr);
        bytes memory result = new bytes(40);
        uint index = 0;

        for (uint i = 0; i < addressBytes.length; i++) {
            uint8 addressByte = uint8(addressBytes[i]);
            result[index] = toHex(addressByte >> 4);
            result[index + 1] = toHex(addressByte & 0xF);
            index += 2;
        }

        return string(result);
    }

    function toHex(uint8 value) private pure returns (bytes1) {
        if (value < 10) {
            return bytes1(48 + value);
        } else {
            return bytes1(97 + (value - 10));
        }
    }
}
