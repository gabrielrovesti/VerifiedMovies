// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19 <0.9.0;

struct Parent {
    bool valid;
    string parentDid;
    string signature;
}

struct VerificationMethod {
    uint index;
    string id;
    string methodType;
    string controller;
    uint chainId;
    address blockchainAccountId;
}

struct Service {
    string id;
    string serviceType;
    string endpoint;
}

struct DidDocument {
    string did;
    bool deactivated;
    VerificationMethod[] authentications;
    uint nextAuthenticationIndex;
    VerificationMethod[] capabilityDelegations;
    uint nextCapabilityDelegationIndex;
    Service[] services;
    uint nextServiceIndex;
    Parent parent;
}

struct ResolutionResult {
    //didResolutionMetadata
    DidDocument didDocument;
    // didDocumentMetadata
}

struct ChainResolutionResult {
    string[] userDids;
}

contract SelfSovereignIdentity {
    mapping(string => DidDocument) private documents;
    // Development-only
    string[] private keys;
    
    //
    // Creates a new DID Document related to the user that has issued the transaction.
    //
    // @return The DID of the newly added user.
    //
    function createDid() public returns (string memory) {
        string memory userDid = addressToDid(msg.sender);

        initializeDidDocument(userDid, msg.sender);

        return userDid;
    }
    
    //
    // Creates a new DID Document stating the "delegation" of trust from the user that issued the
    // transaction (which acts as "certification authority") to the user with the specified DID.
    // Therefore, this method adds the specified DID as the last node of the chain of trust.
    //
    // @param childAddress The address that will be used to compute the DID of the user to which the
    //                     "certification authority" delegates the trust.
    // @param signature Signature generated by the "certification authority"
    // @return The DID of the newly added user.
    //
    function createChildTrustedDid(
        address childAddress,
        string memory signature
    ) public returns (string memory) {
        string memory childDid = addressToDid(childAddress);

        initializeDidDocument(childDid, childAddress);
        // TODO: the sender can use different DID -> verify identity via authentication
        documents[childDid].parent = Parent(true, addressToDid(msg.sender), signature);

        return childDid;
    }

    function initializeDidDocument(string memory userDid, address userAddress) private {
        string memory authenticationId = string.concat(userDid, "#keys-1");
        VerificationMethod memory authentication = VerificationMethod(
            1,
            authenticationId,
            "EcdsaSecp256k1RecoveryMethod2020", // TODO:
            userDid,
            block.chainid,
            userAddress
        );

        documents[userDid].did = userDid;
        documents[userDid].deactivated = false;
        documents[userDid].authentications.push(authentication);
        documents[userDid].nextAuthenticationIndex = 2;
        documents[userDid].nextCapabilityDelegationIndex = 1;
        documents[userDid].nextServiceIndex = 1;

        // Development-only
        keys.push(userDid);
    }
    
    //
    // Adds a capability delegation from the user that issued the transaction to the user whose DID
    // will be computed from the specified address.
    // Therefore, the user that issued the transaction delegates to the specified user the
    // possibility to authenticate as the user that issued the transaction.
    //
    // @param controllerAddress The address of the user that will have the possibility to
    //                          authenticate as the user that issued the transaction.
    //
    function addCapabilityDelegation(address controllerAddress) public {
        string memory userDid = addressToDid(msg.sender);
        string memory controllerDid = addressToDid(controllerAddress);

        DidDocument storage userDidDocument = documents[userDid];

        VerificationMethod memory delegation = VerificationMethod(
            userDidDocument.nextCapabilityDelegationIndex,
            string.concat(
                userDid,
                "#capability-",
                uintToString(userDidDocument.nextCapabilityDelegationIndex)
            ),
            "EcdsaSecp256k1RecoveryMethod2020", // TODO,
            controllerDid,
            block.chainid,
            controllerAddress
        );

        userDidDocument.capabilityDelegations.push(delegation);
        userDidDocument.nextCapabilityDelegationIndex++;
    }

    // TODO: function removeCapabilityDelegation() public {}
    //TODO: addKey
    //TODO: removeKey
    
    function addService(
        string memory serviceId,
        string memory serviceType,
        string memory endpoint
    ) public {
        DidDocument storage document = documents[addressToDid(msg.sender)];

        document.services.push(Service(serviceId, serviceType, endpoint));
        document.nextServiceIndex++;
    }

    //TODO: function removeService(string memory serviceId) public {}
    
    //
    // Deactivates the DID document related to the user that issued the transaction.
    //
    function deactivate() public {
        documents[addressToDid(msg.sender)].deactivated = true;
    }

    //
    // Returns the DID document associated to the user with the specified DID.
    //
    // @param did DID of the user whose DID document will be returned.
    // @return The DID document associated to the user with the specified DID.
    //
    function resolve(string memory did) public view returns (ResolutionResult memory) {
        return ResolutionResult(documents[did]);
        // TODO. resolve(did, resolutionOptions) -> (didResolutionMetadata, didDocument, didDocumentMetadata)
    }
    
    //
    // Returns the chain of trust having as last node the user with the specified DID.
    //
    // @param The DID of the user to compute the chain of trust of.
    // @return The list of DIDs of the users in the chain of trust having the specified DID as the
    //          last node.
    //
    function resolveChain(string memory did) public view returns (ChainResolutionResult memory) {
        string[] memory userDids = new string[](10);
        DidDocument memory currentDocument = documents[did];
        uint8 index = 0;
        bool valid = true;

        do {
            userDids[index] = currentDocument.did;
            valid = currentDocument.parent.valid;
            if (valid) {
                currentDocument = documents[currentDocument.parent.parentDid];
            }
            index++;
        } while (valid);

        return ChainResolutionResult(userDids);
    }

    // TODO: getCapabilityDelegations OR resolve().capabilityDelegations
    
    //
    // Deletes all the DID documents. This method is used for development purposes only.
    //
    function clear() public {
        uint size = keys.length;

        while (size > 0) {
            delete documents[keys[size - 1]];
            keys.pop();
            size--;
        }
    }
    
    //
    // Converts the specified address to the corresponding DID.
    //
    // @param addressToConvert Address to convert to DID.
    // @return The computed DID.
    //
    function addressToDid(address addressToConvert) public view returns (string memory) {
        return
            string.concat(
                "did:ssi-cot-eth:",
                uintToString(block.chainid),
                ":",
                addressToString(addressToConvert)
            );
    }

    function uintToString(uint number) private pure returns (string memory) {
        if (number == 0) {
            return "0";
        }

        // Compute the length
        uint length = 0;
        uint numberCopy = number;
        while (numberCopy > 0) {
            length++;
            numberCopy /= 10;
        }

        bytes memory result = new bytes(length);
        uint index = length - 1;

        while (number > 0) {
            uint8 value = uint8(number % 10);
            result[index] = bytes1(48 + value);
            if (index != 0) {
                index--;
            }
            number /= 10;
        }

        return string(result);
    }

    function addressToString(address addr) private pure returns (string memory) {
        bytes20 addressBytes = bytes20(addr);
        bytes memory result = new bytes(40);
        uint index = 0;

        for (uint i = 0; i < addressBytes.length; i++) {
            uint8 addressByte = uint8(addressBytes[i]);
            result[index] = toHex(addressByte >> 4);
            result[index + 1] = toHex(addressByte & 0xF);
            index += 2;
        }

        return string(result);
    }

    function toHex(uint8 value) private pure returns (bytes1) {
        if (value < 10) {
            return bytes1(48 + value);
        } else {
            return bytes1(97 + (value - 10));
        }
    }
}
